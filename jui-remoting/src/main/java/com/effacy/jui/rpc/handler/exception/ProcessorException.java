/*******************************************************************************
 * Copyright 2024 Jeremy Buckley
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * <p>
 * <a href= "http://www.apache.org/licenses/LICENSE-2.0">Apache License v2</a>
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.effacy.jui.rpc.handler.exception;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;

import org.apache.commons.lang3.StringUtils;

import com.effacy.jui.validation.model.ValidationException;
import com.effacy.jui.validation.model.IValidator.Message;

/**
 * Basic exception generated by processors when unable to perform the processors
 * task.
 * <p>
 * Encapsulated in the exception are {@link Error}'s that reflect the underlying
 * problems.
 *
 * @author Jeremy Buckley
 */
public class ProcessorException extends Exception implements Iterable<ProcessorException.Error> {

    /**
     * Enumerates the various error types.
     */
    public enum ErrorType {
        NOT_FOUND, ACCESS_RIGHTS, VALIDATION, SYSTEM, READ_ONLY, LOCATION, PROCESSING, OTHER;
    }

    /**
     * Encapsulates a single error condition.
     */
    public static class Error {

        /**
         * See {@link #getType()}.
         */
        private ErrorType type;

        /**
         * See {@link #getPath()}.
         */
        private String path;

        /**
         * See {@link #getCode()}.
         */
        private int code = -1;

        /**
         * See {@link #getMessage()}.
         */
        private String message;

        /**
         * Construct with a base error type.
         * 
         * @param type
         *             the type.
         */
        public Error(ErrorType type) {
            this.type = (type == null) ? ErrorType.OTHER : type;
        }

        /**
         * The type of error this is.
         * 
         * @return the type.
         */
        public ErrorType getType() {
            return type;
        }

        /**
         * Assigns a path (target) for the error (for example, a field).
         * <p>
         * Targets are generally used to associated a specific error condition with
         * field. With scoping this extends to sub-component or system. If there is no
         * target then it generally means that the condition is global in some sense.
         * 
         * @param target
         *               the target.
         * @return this error.
         */
        public Error path(String path) {
            this.path = path;
            return this;
        }

        /**
         * Obtains the path (target) of the error.
         * <p>
         * This may be scoped (mostly relevant for commands where there could be
         * multiple) and scopes can be nested. Scopes are separated (from the target and
         * other scopes) by a forward slash. In the case where no target was initially
         * set then it is treated as an empty string and the effect of scoped is the
         * existence of a trailing slash.
         * 
         * @return the target of the error.
         */
        public String getPath() {
            return path;
        }

        /**
         * Assigns an error code.
         * 
         * @param code
         *             the code (keep in mind that -1 is reserved for no code).
         * @return this error.
         */
        public Error code(int code) {
            this.code = code;
            return this;
        }

        /**
         * Any error code (if set, otherwise will be -1).
         * 
         * @return the code.
         */
        public int getCode() {
            return code;
        }

        /**
         * Assigns an error message.
         * 
         * @param message
         *                the message.
         * @return this error.
         */
        public Error message(String message) {
            this.message = message;
            return this;
        }

        /**
         * The error message (if set).
         * 
         * @return the message.
         */
        public String getMessage() {
            return message;
        }

        /**
         * See {@link ProcessorException#scope(String)}.
         * 
         * @param scope
         *              the scope.
         */
        void scope(String scope) {
            if (path == null)
                path = "";
            path = scope + "/" + path;
        }

        /**
         * {@inheritDoc}
         *
         * @see java.lang.Object#toString()
         */
        @Override
        public String toString() {
            StringBuffer sb = new StringBuffer ();
            sb.append ("Error[");
            sb.append ("type=");
            sb.append ((type == null) ? "null" : type.name ());
            sb.append (",path=");
            sb.append (path);
            sb.append (",code=");
            sb.append (code);
            sb.append (",message=\"");
            if (message != null)
                sb.append (message);
            sb.append ("\"");
            sb.append ("]");
            return sb.toString ();
        }

    }

    /**
     * Serialisation ID.
     */
    private static final long serialVersionUID = 7925300584329077032L;

    /**
     * See {@link #isRetry()}.
     */
    private boolean retry;

    /**
     * See {@link #errors()}.
     */
    private List<Error> errors = new ArrayList<> ();

    private boolean passthrough;

    /**
     * Construct with no initial data.
     */
    public ProcessorException() {
        super ();
    }

    /**
     * Construct by extracting messages from a {@link ValidationException}.
     * 
     * @param ex
     *           the exception.
     */
    public ProcessorException(ValidationException ex) {
        super ();

        for (Message msg : ex) {
            Error error = new Error (ErrorType.VALIDATION).path (msg.getPath ()).message (msg.getMessage ());
            this.errors.add (error);
        }
    }

    /**
     * Construct with errors.
     * 
     * @param errors
     *               the errors.
     */
    public ProcessorException(List<Error> errors) {
        super ();

        if (errors != null)
            this.errors.addAll (errors);
    }

    /**
     * For sub-classes to specify a standard error.
     * 
     * @param type
     *                the error type.
     * @param code
     *                the error code (if any).
     * @param message
     *                the message.
     */
    protected ProcessorException(ErrorType type, int code, String message) {
        add (type, error -> {
            error.code (code);
            error.message ((message == null) ? "{" + getClass ().getSimpleName () + "}" : message);
        });
    }

    /**
     * For sub-classes to specify a standard error.
     * <p>
     * If the message is {@code null} then one will be assigned using a substitution
     * mapping based on the class name of this class.
     * 
     * @param type
     *                the error type.
     * @param code
     *                the error code (if any).
     * @param path
     *                the associated path.
     * @param message
     *                the message.
     */
    protected ProcessorException(ErrorType type, int code, String path, String message) {
        add (type, error -> {
            error.code (code);
            error.path (path);
            error.message ((message == null) ? "{" + getClass ().getSimpleName () + "}" : message);
        });
    }

    public ProcessorException passthrough() {
        this.passthrough = true;
        return this;
    }

    public boolean isPassthrough() {
        return this.passthrough;
    }

    /**
     * Provides a scope on all error message targets, the scope will be separated
     * from the target (which may already be scoped) with a forward slash.
     * <p>
     * If the target is not present will be treated as empty (so there will be a
     * trailing slash).
     * 
     * @param scope
     *              the scope to apply.
     * @return this exception.
     */
    public ProcessorException scope(String scope) {
        if (!StringUtils.isBlank (scope))
            errors.forEach (e -> e.scope (scope));
        return this;
    }

    /**
     * See {@link #add(ErrorType, Consumer)}. Convenience to configure specific
     * attributes.
     * 
     * @return this exception.
     */
    public ProcessorException add(ErrorType type, String message) {
        errors.add (new ProcessorException.Error (type).message (message));
        return this;
    }

    /**
     * See {@link #add(ErrorType, Consumer)}. Convenience to configure specific
     * attributes.
     * 
     * @return this exception.
     */
    public ProcessorException add(ErrorType type, String target, String message) {
        errors.add (new ProcessorException.Error (type).path (target).message (message));
        return this;
    }

    /**
     * See {@link #add(ErrorType, Consumer)}. Convenience to configure specific
     * attributes.
     * 
     * @return this exception.
     */
    public ProcessorException add(ErrorType type, String target, int code, String message) {
        errors.add (new ProcessorException.Error (type).path (target).code (code).message (message));
        return this;
    }

    /**
     * Adds an error of the given type and a means to configure attributes of the
     * error.
     * 
     * @param type
     *              the type of error.
     * @param error
     *              means to configure the attributes of the error.
     * @return this exception.
     */
    public ProcessorException add(ErrorType type, Consumer<ProcessorException.Error> error) {
        ProcessorException.Error e = new ProcessorException.Error (type);
        if (error != null)
            error.accept (e);
        errors.add (e);
        return this;
    }

    /**
     * Marks the problem as being amenable to retry (i.e. could be temporary).
     * 
     * @return the exception.
     */
    public ProcessorException retry() {
        this.retry = true;
        return this;
    }

    /**
     * Determines if the problem is amenable to retry.
     * 
     * @return {@code true} if it is.
     */
    public boolean isRetry() {
        return retry;
    }

    /**
     * {@inheritDoc}
     *
     * @see java.lang.Iterable#iterator()
     */
    @Override
    public Iterator<ProcessorException.Error> iterator() {
        return errors.iterator ();
    }

    /**
     * The accumulated errors.
     * 
     * @return the errors.
     */
    public List<ProcessorException.Error> errors() {
        return errors;
    }

}
